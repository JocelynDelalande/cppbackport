#include "TransformBase/TransformHandler.h"
#include "Util/TransformUtility.h"
#include "Util/StringUtility.h"
#include "Util/Log.h"
#include "Util/StringReplacer.h"
#include "ReplaceLambdaMatchers.h"
#include "clang/AST/RecursiveASTVisitor.h"

using namespace backport::helper;
using namespace clang::ast_matchers;
using namespace clang::tooling;

typedef ReplacerTemplate<class Lambda> LambdaReplacer;

// Recursive AST Visitor for this pointer locations
class CXXThisExprVisitor
    : public RecursiveASTVisitor<CXXThisExprVisitor> {
    friend class RecursiveASTVisitor<CXXThisExprVisitor>;

public:
    CXXThisExprVisitor() {}

    // Returns containing this expressions (implicit and explicit)
    std::vector<CXXThisExpr*> collectDeclRefExpressions(const Stmt *stmt) {
        TraverseStmt(const_cast<Stmt *>(stmt));
        return containingCXXThisExpr;
    }

private:
    // Collects CXXThis expressions
    bool VisitCXXThisExpr(CXXThisExpr *D) {
        containingCXXThisExpr.push_back(D);
        return true;
    }

    std::vector<CXXThisExpr*> containingCXXThisExpr;
};

// Converts the anonymous lambda class type name generated by clang into a valid typename
static inline std::string lambdaTypeConverter(const std::string& varType, bool local) {
    std::string lamdaTypeName = varType;
    llvm::Regex posRegex("^\\(lambda at.*:([0-9]+):([0-9]+)\\)$");
    if (posRegex.match(lamdaTypeName)) {
        auto row = lamdaTypeName;
        row = posRegex.sub("\\1", row);
        auto col = lamdaTypeName;
        col = posRegex.sub("\\2", col);
        lamdaTypeName = (local ? std::string("LambdaFunctorCaller_") : std::string("LambdaFunctor_")) /*+ filename*/ + std::string("_") + row + std::string("_") + col;
    }
    return lamdaTypeName;
}

// Merges a function pointer type and name properly
static inline std::string functionPointerTypeConverter(std::string typeStr, std::string nameStr) {
    if (typeStr.find("( * )") != std::string::npos) {
        unsigned int pos = typeStr.find("( * )");
        typeStr = typeStr.substr(0, pos) + typeStr.substr(pos + 5);
    }

    std::string functionPointerName = "(*" + nameStr + ")";
    unsigned int pos = typeStr.find("(");
    typeStr = typeStr.substr(0, pos) + functionPointerName + typeStr.substr(pos);

    // Clang might determine that the function is const, but function pointers can't be const so we need to remove it
    if ((typeStr.size() > 4) && (typeStr.substr(typeStr.size() - 5).compare("const") == 0)) {
        typeStr = typeStr.substr(0, typeStr.size() - 5);
    }

    return typeStr;
}

// Determines wheter or not the type is dependent on a local type
// FIXME : This would need proper recursive type analysis to find local classes deeper (as template argument, function pointer parameter, ect..)
bool hasLocalClass(const QualType& q) {
    auto typePtr = q.getTypePtr();
    if (typePtr->isPointerType() || typePtr->isReferenceType() || typePtr->isRValueReferenceType()) {
        return hasLocalClass(typePtr->getPointeeType());
    } else if (typePtr->isRecordType()) {
        auto recordDecl = typePtr->getAsCXXRecordDecl();
        if (recordDecl != nullptr) {
            return recordDecl->isLocalClass();
        }
    }
    return false;
}

std::shared_ptr<SplittableString> getDesugaredTypeString(QualType const &q, Transform &Owner, SourceManager &SM, ASTContext *Context);

std::pair<std::shared_ptr<SplittableString>, bool> replacer(clang::QualType const &q, Transform &Owner, SourceManager &SM, ASTContext *Context) {
    // If it doesn't contain more decltype and the type is simple(the variable name is not inside of the type like in function types) then just print.
    if (hasSubType(q, [](QualType const &t) { return dyn_cast<DecltypeType>(t.getTypePtr()) != nullptr; }) == false &&
        hasSubType(q, [](QualType const &t) { return t->isFunctionType() || t->isFunctionProtoType() || t->isPointerType(); }) == false &&
        hasSubType(q.getCanonicalType(), [](QualType const &t) { return dyn_cast<DecltypeType>(t.getTypePtr()) != nullptr; }) == false &&
        hasSubType(q.getCanonicalType(), [](QualType const &t) { return t->isFunctionType() || t->isFunctionProtoType() || t->isPointerType(); }) == false) {
        if (q.isConstQualified()) {
            auto tmpttype = q.getCanonicalType();
            tmpttype.removeLocalConst();
            auto tmp = getDesugaredTypeString(tmpttype, Owner, SM, Context);
            return std::make_pair<std::shared_ptr<SplittableString>, bool>(std::make_shared<SplittableString>(tmp->first + " const ", tmp->second), true);
        } else if (q.isVolatileQualified()) {
            auto tmpttype = q.getCanonicalType();
            tmpttype.removeLocalVolatile();
            auto tmp = getDesugaredTypeString(tmpttype, Owner, SM, Context);
            return std::make_pair<std::shared_ptr<SplittableString>, bool>(std::make_shared<SplittableString>(tmp->first + " volatile ", tmp->second), true);
        } else if (q->isRecordType() && q->getAsCXXRecordDecl() != nullptr) {
            if (q->getAsCXXRecordDecl()->isLambda()) {
                // Deal with lambda types
                auto lambdaRecord = q->getAsCXXRecordDecl();
                if (lambdaRecord->captures().begin() == lambdaRecord->captures().end()) {
                    // Return function pointer
                    return std::make_pair<std::shared_ptr<SplittableString>, bool>(std::make_shared<SplittableString>(printToString(lambdaRecord->getLambdaCallOperator()->getAsFunction()->getType())), false);
                } else {
                    bool local = true;
                    return std::make_pair<std::shared_ptr<SplittableString>, bool>(std::make_shared<SplittableString>(lambdaTypeConverter(printToString(q.getCanonicalType()), local)), false);
                }
            } else {
                // if the type is an unnamed class the getName will name it.
                return std::make_pair<std::shared_ptr<SplittableString>, bool>(std::make_shared<SplittableString>(getQualifiedNameAsStringWithTemplateArgs(q.getCanonicalType()->getAsCXXRecordDecl(), Owner, SM)), false);
            }
        } else if (hasSubType(q.getCanonicalType(), [](QualType const &t) { return t->isRecordType() && t->getAsCXXRecordDecl() != nullptr && isUnnamed(t->getAsCXXRecordDecl()); })) {
            return{ nullptr, false };
        } else {
            return std::make_pair<std::shared_ptr<SplittableString>, bool>(std::make_shared<SplittableString>(printToString(q.getCanonicalType())), false);
        }
    } else if (dyn_cast<DecltypeType>(q.getTypePtr()) != nullptr) {
        // If desugaring doesn't get rid of a direct decltype try it again.

        if ((dyn_cast<DecltypeType>(q.getTypePtr())->isSugared()) && (q.getCanonicalType() == q) && (dyn_cast<DecltypeType>(q.getCanonicalType().getTypePtr()))) {
            return std::make_pair<std::shared_ptr<SplittableString>, bool>(nullptr, true);
        } else if (dyn_cast<DecltypeType>(q.getTypePtr())->isSugared() == false) {
            return std::make_pair<std::shared_ptr<SplittableString>, bool>(getDesugaredTypeString(dyn_cast<DecltypeType>(q.getTypePtr())->getUnderlyingType(), Owner, SM, Context), true);
        }

        // Otherwise desugar current decltype and continue. (A desugared type can still contain decltype, for example as a function type's parameter type)
        return std::make_pair<std::shared_ptr<SplittableString>, bool>(getDesugaredTypeString(q.getCanonicalType(), Owner, SM, Context), true);
    }

    return std::make_pair<std::shared_ptr<SplittableString>, bool>(nullptr, false);
}

std::shared_ptr<SplittableString> getDesugaredTypeString(QualType const &q, Transform &Owner, SourceManager &SM, ASTContext *Context) {
    return replaceTypeRecursivly(q, Owner, SM, Context, replacer);
}

// Replace lambda functions with appropriate functor class(es)
template<>
void LambdaReplacer::run(const MatchFinder::MatchResult &Result) {
    SourceManager &SM = *Result.SourceManager;

    const LambdaExpr *E = Result.Nodes.getNodeAs<clang::LambdaExpr>(LambdaExprId);
    assert(E && "Bad Callback. No node provided");

    if (!Owner.isFileModifiable(SM, E->getLocStart())) {
        return;
    }
    
    // If the matcher found an ancestor lambda node, then don't process this node, but mark the file for another round of lambda transformation
    const LambdaExpr *A = Result.Nodes.getNodeAs<clang::LambdaExpr>(LambdaAncestor);
    if (A != nullptr) {
        Owner.TransformationSourceMap[ReplaceLambdaID].insert(Owner.getCurrentSource());
        return;
    }

    // We want to insert the main functor right before the expression that contains the lambda
    auto CESR = getContainingExpressionRange(E, *Result.Context);

    // We're not gonna replace the entire expression that contains the lambda, just the lambda expression itself
    CharSourceRange call_range = CharSourceRange::getTokenRange(
        SM.getSpellingLoc(E->getSourceRange().getBegin()),
        SM.getSpellingLoc(E->getSourceRange().getEnd()));

    // If the containing expressin doesn't start right at the very beginning of the file, then offset the insertion point by one
    CharSourceRange functor_range = makeInsertionPoint(CESR.getBegin());
    if ((SM.getSpellingLineNumber(functor_range.getBegin()) > 1) || (SM.getSpellingColumnNumber(functor_range.getBegin()) > 1)) {
        functor_range = makeInsertionPoint(CESR.getBegin().getLocWithOffset(-1));
    }

    // If we have to worry about the local classes problem, then we'll need to insert some helper classes right before the function that contains the lambda node
    SourceLocation outerBegin = getOuterDeclarationRange(E, *Result.Context).getBegin();
    if ((SM.getSpellingLineNumber(outerBegin) > 1) || (SM.getSpellingColumnNumber(outerBegin) > 1)) {
        outerBegin = outerBegin.getLocWithOffset(-1);
    }
    CharSourceRange outer_range = makeInsertionPoint(outerBegin);

    // In gcc local classes can't be used as template arguments. To get around this limitation, extra non-local classes need to be generated
    // NOTE : A lambda is local if it's defined within a function or method
    bool local = true;
    auto target = Owner.getTargetCompilerVersions();
    if (!target.Msvc.isNull() || !target.Clang.isNull()) {
        // Since Msvc supports local classes as template arguments, we can consider everything non-local
        local = false;
    } else {
        // The outer range and functor range are only equal if the lambda expresion is not within a function
        if (outer_range.getBegin() == functor_range.getBegin()) {
            local = false;
        }
    }

    auto Policy = getPrintingPolicy();

    // The stream where the call to the lambda functor constructor is constructed
    std::string s1;
    llvm::raw_string_ostream rso_call(s1);

    // The stream where the lambda functor class is constructed
    std::string s2;
    llvm::raw_string_ostream rso_class(s2);

    // The stream where the original lambda function body is printed
    std::string s3;
    llvm::raw_string_ostream rso_body(s3);

    // The stream where the unique name endig of the generated classes is constructed
    std::string s4;
    llvm::raw_string_ostream rso_name(s4);

    // The stream where the virtual function of the base class is constructed
    std::string s5;
    llvm::raw_string_ostream rso_basefunc(s5);

    // The stream where the actual function that executes the original lambda is constructed
    std::string s6;
    llvm::raw_string_ostream rso_callerfunc(s6);

    // The stream where the base class for inheritance is constructed
    std::string s7;
    llvm::raw_string_ostream rso_base(s7);

    // The stream where the base class caller class is constructed
    std::string s8;
    llvm::raw_string_ostream rso_caller(s8);

    // The stream where the call parameter list is constructed
    std::string s9;
    llvm::raw_string_ostream rso_callparameters(s9);

    // The stream where a simpler call class is created around a static function, used when the lambda has no captures and decay to a simple function pointer
    std::string s10;
    llvm::raw_string_ostream rso_fptrclass(s10);

    // If the line and column numbers are not enough to generate unique class names, the filename could also be used
    std::string filename = "";
    rso_name << "_" << filename << "_" << SM.getSpellingLineNumber(E->getLocStart()) << "_" << SM.getSpellingColumnNumber(E->getLocStart());

    // Start the lambda functor class
    rso_class << "\nclass LambdaFunctor" << rso_name.str();
    rso_fptrclass << "\nclass LambdaFunctor" << rso_name.str() << " {\n";
    rso_fptrclass << "public:\n";
    if (local) {
        // If we need to worry about it being local, we'll need to derive from the base class
        rso_class << " : public LambdaFunctorBase" << rso_name.str() << " {\n";
    } else {
        rso_class << " {\n";
    }

    // If the lambda is not mutable, then the calling of the labda functor is a const operation
    std::string lambdaFunctorConstOperator = (E->isMutable()) ? "" : " const";

    // We'll monitor if the this pointer is captured
    bool thisCaptured = false;

    // The capture list will be transformed into the class members of the functor class
    for (auto& c : E->getLambdaClass()->captures()) {
        if (c.getCaptureKind() != LambdaCaptureKind::LCK_This) {
            // Get the type of the variable
            // If there is a lambda expression amongst the captures
            auto varType = *getDesugaredTypeString(c.getCapturedVar()->getType().getCanonicalType(), Owner, SM, Result.Context);

            if (varType.find("(") != std::string::npos) {
                // If the type contains a "(" it must be a function pointer
                varType = functionPointerTypeConverter(varType, c.getCapturedVar()->getName().str());

                // The varType incorporates the name of the function pointer
                rso_class << varType << ";\n";
            } else {
                // If we capture by reference we need to append a reference after the type
                // Unless we capture a reference by reference, in whitch case it'll stay a simple reference. No need to append '&' as it is already contained in the type
                rso_class << varType;
                if (c.getCaptureKind() == LambdaCaptureKind::LCK_ByCopy) {
                    rso_class << " ";
                    // When capturing by value and not reference a copie is created, but it's const unless the lambda is mutable
                    if (!E->isMutable()) {
                        if ((varType.size() < 2) || ((varType.at(varType.size() - 1) != '&') && (varType.at(varType.size() - 2) != '&'))) {
                            rso_class << "const ";
                        }
                    }
                } else if (c.getCaptureKind() == LambdaCaptureKind::LCK_ByRef) {
                    if ((varType.size() >= 2) && ((varType.at(varType.size() - 1) == '&') || (varType.at(varType.size() - 2) == '&'))) {
                        rso_class << " ";
                    } else {
                        rso_class << "& ";
                    }
                }

                // After the type we add the name of the variable
                rso_class << c.getCapturedVar()->getName().str() << ";\n";
            }
        } else {
            thisCaptured = true;

            // We'll need the type of the this pointer, so we can make a class member of the appropriate type
            const CXXThisExpr *TE = Result.Nodes.getNodeAs<clang::CXXThisExpr>(LambdaThisCapture);
            auto varType = *getDesugaredTypeString(TE->getType().getCanonicalType(), Owner, SM, Result.Context);

            // We'll store the this pointer in a member named 'lambdaThisCapture'
            rso_class << varType << " lambdaThisCapture;\n";
        }
    }

    // Start the constructor of the generated functor class and the call to said constructor
    rso_class << "public:\nLambdaFunctor" << rso_name.str() << "(";
    if (local) {
        rso_call << "LambdaFunctorCaller" << rso_name.str() << "(new LambdaFunctor" << rso_name.str() << "(";
    } else {
        rso_call << "LambdaFunctor" << rso_name.str() << "(";
    }

    // We iterate through the captures again
    bool first = true;
    for (auto& c : E->getLambdaClass()->captures()) {
        if (!first) {
            rso_call << ", ";
            rso_class << ", ";
        }

        // For the constructor we list the proper typenames
        if (c.getCaptureKind() != LambdaCaptureKind::LCK_This) {
            auto varType = *getDesugaredTypeString(c.getCapturedVar()->getType().getCanonicalType(), Owner, SM, Result.Context);

            if (varType.find("(") != std::string::npos) {
                // If the type contains a "(" it must be a function pointer
                varType = functionPointerTypeConverter(varType, c.getCapturedVar()->getName().str());

                // The capture names are listed for the call
                // For the class the varType now incorporates the name of the function pointer
                rso_call << c.getCapturedVar()->getName().str();
                rso_class << varType;
            } else {
                rso_class << varType;
                if (c.getCaptureKind() == LambdaCaptureKind::LCK_ByCopy) {
                    rso_class << " ";
                } else if (c.getCaptureKind() == LambdaCaptureKind::LCK_ByRef) {
                    if ((varType.size() >= 2) && ((varType.at(varType.size() - 1) == '&') || (varType.at(varType.size() - 2) == '&'))) {
                        rso_class << " ";
                    } else {
                        rso_class << "& ";
                    }
                }

                // The capture names are listed for buth constructor and call
                rso_call << c.getCapturedVar()->getName().str();
                rso_class << c.getCapturedVar()->getName().str();
            }
        } else {
            const CXXThisExpr *TE = Result.Nodes.getNodeAs<clang::CXXThisExpr>(LambdaThisCapture);

            auto varType = *getDesugaredTypeString(TE->getType().getCanonicalType(), Owner, SM, Result.Context);

            // We refer to the this pointer as 'lambdaThisCapture' in the functor class
            // And we will initialize it with the 'this' pointer
            rso_class << varType << " lambdaThisCapture";
            rso_call << "this";
        }

        first = false;
    }

    // Did the lambda have no captures
    bool noCaptures = false;

    // If the capture list is empty, we add a 'const int&' to the constructor and call it with '0'
    // This is necessary to avoid the most vexing parse
    if (first) {
        rso_class << "const int&";
        rso_call << "0";
        noCaptures = true;
    }

    if (local) {
        rso_call << ")";
    }
    rso_call << ")";
    rso_class << ")";

    // We iterate through the captures a final time to generate the initializer list of the constructor
    // It's simple as every class member is initialized with the constructor parameter of the same name
    first = true;
    for (auto& c : E->getLambdaClass()->captures()) {
        if (first) {
            rso_class << " : ";
        } else {
            rso_class << ", ";
        }

        if (c.getCaptureKind() != LambdaCaptureKind::LCK_This) {
            rso_class << c.getCapturedVar()->getName().str() << "(" << c.getCapturedVar()->getName().str() << ")";
        } else {
            rso_class << "lambdaThisCapture(lambdaThisCapture)";
        }

        first = false;
    }

    // Normally we shouldn't need to do anything in the constructor after initialization is done
    // But in the case of local lambda, we need to do some caller - functor ownership management
    if (local) {
        rso_class << " { this->lambdaFunctorOwner = 0; }\n";
    } else {
        rso_class << " {}\n";
    }

    // Start the operator() of the functor class
    bool decltypeReturnType = false;
    std::string lambdaReturnType;

    lambdaReturnType = *getDesugaredTypeString(E->getLambdaClass()->getLambdaCallOperator()->getReturnType().getCanonicalType(), Owner, SM, Result.Context);

    // FIXME : Clang Bug : If the lambda is in a generic template class, and the return type of the lambda isn't explicitly given.
    //  Then clang will fail to deduce the return type, even if it's not template dependent.
    //  If the class isn't explicitly instantiated by the InstantiateTemplate transformation, we can't do the lambda transformation.
    if (lambdaReturnType.compare(std::string("<dependent type>")) == 0) {
        LOG(logWARNING) << "Lambda with dependent return type found in " << Owner.getCurrentSource() << " at " << SM.getSpellingLineNumber(E->getLocStart()) << ":" << SM.getSpellingColumnNumber(E->getLocStart());
        return;
    }

    // A string to store the end part of a function pointer return type if necessary
    std::string lambdaReturnTypeFunctionPointerSuffix = "";

    if (lambdaReturnType.find("decltype", 0) == 0) {
        // If the return type still contains 'decltype' then it's a dependent type at this point
        // We'll generate an auto function from it, and leave it to a later transformation to figure out the type
        decltypeReturnType = true;
        if (local) {
            // In the case of local lambda, it's actuall a function called 'lambdaFunc' that preforms the action
            // The class LambdaFuncCaller will have an operator() that calls this 'lambdaFunc' function
            rso_class << "auto lambdaFunc(";
        } else {
            rso_class << "auto operator()(";
        }
        rso_fptrclass << "static auto lambdaFunc(";
        rso_basefunc << "virtual auto lambdaFunc(";
        rso_callerfunc << "auto operator()(";
        Owner.TransformationSourceMap[MultipleTransformsID].insert(Owner.getCurrentSource());
    } else {
        if (lambdaReturnType.find("(") != std::string::npos) {
            // If the type contains a "(" it must be a function pointer
            lambdaReturnType = functionPointerTypeConverter(lambdaReturnType, "#");
            unsigned int pos = lambdaReturnType.find("#");
            lambdaReturnTypeFunctionPointerSuffix = lambdaReturnType.substr(pos + 1);
            lambdaReturnType = lambdaReturnType.substr(0, pos);
        }

        if (local) {
            // In the case of local lambda, it's actuall a function called 'lambdaFunc' that preforms the action
            // The class LambdaFuncCaller will have an operator() that calls this 'lambdaFunc' function
            rso_class << lambdaReturnType << " lambdaFunc(";
        } else {
            rso_class << lambdaReturnType << " operator()(";
        }
        rso_fptrclass << "static " << lambdaReturnType << " lambdaFunc(";
        rso_basefunc << "virtual " << lambdaReturnType << " lambdaFunc(";
        rso_callerfunc << lambdaReturnType << " operator()(";
    }

    // The parameters of the lambda function will be the parameters of the operator() (and lambdaFunc)
    first = true;
    for (auto& p : E->getCallOperator()->parameters()) {
        if (!first) {
            rso_class << ", ";
            rso_fptrclass << ", ";
            rso_basefunc << ", ";
            rso_callerfunc << ", ";
            rso_callparameters << ", ";
        }

        // If a lambda has a local class as a parameter we can't transform it on gcc
        if (local) {
            if(hasLocalClass(p->getType())) {
                LOG(logWARNING) << "Lambda with local class parameter found in " << Owner.getCurrentSource() << " at " << SM.getSpellingLineNumber(E->getLocStart()) << ":" << SM.getSpellingColumnNumber(E->getLocStart());
                return;
            }
        }

        std::string paramType;
        paramType = *getDesugaredTypeString(p->getType().getCanonicalType(), Owner, SM, Result.Context);

        if (paramType.find("(") != std::string::npos) {
            // If the type contains a "(" it must be a function pointer
            paramType = functionPointerTypeConverter(paramType, p->getDeclName().getAsString());

            // The capture names are listed for the call
            // For the class the varType now incorporates the name of the function pointer
            rso_class << paramType;
            rso_fptrclass << paramType;
            rso_basefunc << paramType;
            rso_callerfunc << paramType;
            rso_callparameters << p->getDeclName().getAsString();
        } else {
            rso_class << paramType << " " << p->getDeclName().getAsString();
            rso_fptrclass << paramType << " " << p->getDeclName().getAsString();
            rso_basefunc << paramType << " " << p->getDeclName().getAsString();
            rso_callerfunc << paramType << " " << p->getDeclName().getAsString();
            rso_callparameters << p->getDeclName().getAsString();
        }

        first = false;
    }

    // If the lambda has a return value, then from the caller class we'll need to return the result of calling the functor
    std::string returnstr = "";
    if (lambdaReturnType.compare("void") != 0) { returnstr = "return "; }

    // Close the function declaration using suffix return type syntax if the returntype is dependent
    //   In the functor the definition is generated in the next step
    //   In the base class the function is just a virtual declaration
    //   In the caller we call the lambdaFunc of the base class (actually the functor that inherits from the base class)
    if (decltypeReturnType) {
        rso_class << ")" << lambdaFunctorConstOperator << " -> " << lambdaReturnType << "\n";
        rso_fptrclass << ")" << " -> " << lambdaReturnType << "\n";
        rso_basefunc << ")" << lambdaFunctorConstOperator << " -> " << lambdaReturnType << " = 0;\n";
        rso_callerfunc << ")" << lambdaFunctorConstOperator << " -> " << lambdaReturnType << " { " << returnstr << "lambdaFunctorBase->lambdaFunc(" << rso_callparameters.str() << "); }\n";
    } else {
        rso_class << ")" << lambdaFunctorConstOperator << lambdaReturnTypeFunctionPointerSuffix << "\n";
        rso_fptrclass << ")" << lambdaReturnTypeFunctionPointerSuffix << "\n";
        rso_basefunc << ")" << lambdaFunctorConstOperator << lambdaReturnTypeFunctionPointerSuffix << " = 0;\n";
        rso_callerfunc << ")" << lambdaFunctorConstOperator << lambdaReturnTypeFunctionPointerSuffix << " { " << returnstr << "lambdaFunctorBase->lambdaFunc(" << rso_callparameters.str() << "); }\n";
    }
    
    // The function body of the lambda expression will be inserted into the functor class
    // We have to make sure that the all implicit and explicit uses of the this pointer are properly converted
    StringReplacer lambdaBodyReplacer(getSourceCode(SM, getFullRange(SM, E->getBody()->getSourceRange())));
    if (thisCaptured) {
        // Use custom RecursiveASTVisitor to find all this expressin nodes
        CXXThisExprVisitor visitor;
        auto containingCXXThisExpr = visitor.collectDeclRefExpressions(E);

        // To get the offsets relative to the body string, we'll need to subtract the starting offset of the body in the source
        int lambdaStartOffset = SM.getDecomposedSpellingLoc(E->getBody()->getSourceRange().getBegin()).second;

        // Add the replacements for the this expressions
        for (const auto& thisExpr : containingCXXThisExpr) {
            if (thisExpr->isImplicit()) {
                // If it's an implicit use it's a dereference, so we'll insert "lambdaThisCapture->"
                // We'll also need to enclose the expression in parenthesis to maintain operator priority
                unsigned int startOffset = SM.getDecomposedSpellingLoc(thisExpr->getSourceRange().getBegin()).second - lambdaStartOffset;
                unsigned int endOffset = SM.getDecomposedSpellingLoc(getTokenEnd(SM, thisExpr->getSourceRange().getEnd())).second - lambdaStartOffset;
                if (startOffset != endOffset) {
                    lambdaBodyReplacer.addReplacement("(lambdaThisCapture->", startOffset, startOffset);
                    lambdaBodyReplacer.addReplacement(")", endOffset, endOffset);
                } else {
                    LOG(logWARNING) << "Lambda incorrect implicit this expression range in " << Owner.getCurrentSource() << " at " << SM.getSpellingLineNumber(thisExpr->getLocStart()) << ":" << SM.getSpellingColumnNumber(thisExpr->getLocStart());
                    lambdaBodyReplacer.addReplacement("lambdaThisCapture->", startOffset, startOffset);
                }
            } else {
                // If it's an explicitly written this, it's exact use is unknown, but we only need to replace it with "lambdaThisCapture"
                unsigned int startOffset = SM.getDecomposedSpellingLoc(thisExpr->getSourceRange().getBegin()).second - lambdaStartOffset;
                lambdaBodyReplacer.addReplacement("lambdaThisCapture", startOffset, startOffset + 4);
            }
        }
    }
    rso_body << lambdaBodyReplacer.applyReplacements() << "\n";
    rso_class << rso_body.str();
    rso_fptrclass << rso_body.str() << "};\n";

    // Local lamdas will need a destructor
    if (local) {
        rso_class << "~LambdaFunctor" << rso_name.str() << "() {}\n";
    }
    rso_class << "};\n";

    // The base class has all the proper functions as virtual, the functor will inherit and define them
    rso_base << "\n";
    rso_base << "class LambdaFunctorCaller" << rso_name.str() << ";\n";
    rso_base << "class LambdaFunctorBase" << rso_name.str() << " {\n";
    rso_base << "public:\n";
    rso_base << "    LambdaFunctorCaller" << rso_name.str() << "* lambdaFunctorOwner;\n";
    rso_base << "    " << rso_basefunc.str();
    rso_base << "    virtual ~LambdaFunctorBase" << rso_name.str() << "() {}\n";
    rso_base << "};\n";

    // The caller gets a pointer to the functor in it's constructor and calls it's lambdaFunc methode when needed
    rso_caller << "\n";
    rso_caller << "class LambdaFunctorCaller" << rso_name.str() << " {\n";
    rso_caller << "public:\n";
    rso_caller << "    LambdaFunctorBase" << rso_name.str() << "* lambdaFunctorBase;\n";
    rso_caller << "    " << rso_callerfunc.str();
    rso_caller << "    LambdaFunctorCaller" << rso_name.str() << "(LambdaFunctorBase" << rso_name.str() << "* lambdaFunctorBase) : lambdaFunctorBase(lambdaFunctorBase) { lambdaFunctorBase->lambdaFunctorOwner = this; }\n";
    rso_caller << "    ~LambdaFunctorCaller" << rso_name.str() << "() {\n";
    rso_caller << "        if ((lambdaFunctorBase != 0) && (this == lambdaFunctorBase->lambdaFunctorOwner)) {\n";
    rso_caller << "            delete lambdaFunctorBase;\n";
    rso_caller << "            lambdaFunctorBase = 0;\n";
    rso_caller << "        }\n";
    rso_caller << "    }\n";
    rso_caller << "};\n";

    if (!noCaptures) {
        // If there were captures, we'll need to do replace the lambda with a functor and helper classes

        // We replace the lambda expression with a call the constructor of the proper class
        Owner.addTracedReplacement(SM, call_range, std::string("(") + rso_call.str() + std::string(")"), SM.getSpellingLineNumber(E->getLocStart()));

        // We instert the functor before the expression that contained the lambda
        Owner.addTracedReplacement(SM, functor_range, rso_class.str(), SM.getSpellingLineNumber(E->getLocStart()));

        // If the lambda is local, we need to insert the helper classes before the function that contains the lambda
        if (local) {
            // If the lambda is used within a class, it's possible to have a private type defined in the class as capture, call or return parameter of the lambda function
            // The problem is, that if the class is defined in a header and the function declarations are outside the class body, the lambda base and caller classes will be declared outside of the class
            // Thus they can't use the private types of the class. To solve this problem, these two classes will be declared friend inside the class.

            std::string missingNamespace = "";

            // Find the first CXXMethodDecl going up in the AST
            const CXXMethodDecl* parentMethodDecl =
                getFirstContainingParent_which_as<CXXMethodDecl>(E, *Result.Context, [&](clang::ast_type_traits::DynTypedNode const &current) {
                    return ((current.get<CXXMethodDecl>() != nullptr) || (current.get<TranslationUnitDecl>() != nullptr));
                } );
            if (parentMethodDecl != nullptr) {
                // If we found a CXXMethodDecl node up the AST, then we were in a class method
                // We move to the containing pranet class and insert the friend declarations at the end
                auto parentDecl = parentMethodDecl->getParent();

                // Get the enclosing written namespaces for where the class method is defined and where it's declared
                auto lambdaNamespace = getCurrentNamespace(E, *Result.Context, false);
                auto classNamespace = getCurrentNamespace(parentDecl, *Result.Context, false);

                // If it's different, then we'll need to open the missing namespaces do declare the helper lambda classes
                missingNamespace = classNamespace.substr(classNamespace.find(lambdaNamespace) + lambdaNamespace.size());

                // The friend declarations for the lambda classes
                std::string friendDeclaration = "friend class LambdaFunctorBase" + rso_name.str() + ";\nfriend class LambdaFunctorCaller" + rso_name.str() + ";\n";

                // We need to insert the friend declaration in the class whose method the lambda is used in, but also any outer classes
                while (parentDecl != nullptr) {
                    // Add the friend declaration at the end of the current class declaration
                    auto recordDeclEnd = makeInsertionPoint(parentDecl->getSourceRange().getEnd());
                    Owner.addTracedReplacement(SM, recordDeclEnd, friendDeclaration, SM.getSpellingLineNumber(E->getLocStart()));

                    // Find the nect class declaration up in the AST if any
                    parentDecl =
                        getFirstContainingParent_which_as<CXXRecordDecl>(parentDecl, *Result.Context, [&](clang::ast_type_traits::DynTypedNode const &current) {
                            // If we reached the TranslationUnitDecl, return true, the casting to CXXRecordDecl will return nullptr, so the while will stop
                            if (current.get<TranslationUnitDecl>() != nullptr) {
                                return true;
                            }

                            // If we have a CXXRecordDecl that is not a lambda and has a definition, we found an outer class
                            auto redordDecl = current.get<CXXRecordDecl>();
                            if (redordDecl != nullptr) {
                                return (!redordDecl->isLambda() && redordDecl->hasDefinition());
                            }

                            return false;
                        } );
                }
            }

            // The stream where we put together the final form of the helper classes declarations
            std::string s11;
            llvm::raw_string_ostream rso_helperClasses(s11);
            if (missingNamespace.size() == 0) {
                // If there is no missing namespace, we can just insert the declarations for the base and the caller
                rso_helperClasses << rso_base.str() << rso_caller.str();
            } else {
                // If there are missing namespaces, we need to open all, and close them after the declarations
                rso_helperClasses << "\n";

                // There will be an extra "::" at the end of the missingNamespace string if it's not empty
                missingNamespace = missingNamespace.substr(0, missingNamespace.size() - 2);

                // We split the string by the ':' characters
                auto namespaces = split(missingNamespace, ':');
            
                for (const auto& ns : namespaces) {
                    // Because we can't use split to split by "::" there will be empty tokens, but we can just skip those not a real problem
                    if (ns.size() > 0) {
                        // Open all the missing namespaces
                        rso_helperClasses << "namespace " << ns << " {\n";
                    }
                }

                // Insert the declarations
                rso_helperClasses << rso_base.str() << rso_caller.str();


                for (const auto& ns : namespaces) {
                    // Again, skip empty tokes
                    if (ns.size() > 0) {
                        // Close the namespaces
                        rso_helperClasses << "} /* " << ns << " */\n";
                    }
                }
            }

            Owner.addTracedReplacement(SM, outer_range, rso_helperClasses.str(), SM.getSpellingLineNumber(E->getLocStart()));
        }
    } else {
        // If there weren't any captures, we can replace the lambda with a wrapper class with a static function

        // We replace the lambda expression with a call the static function of the proper class
        Owner.addTracedReplacement(SM, call_range, std::string("LambdaFunctor") + rso_name.str() + std::string("::lambdaFunc"), SM.getSpellingLineNumber(E->getLocStart()));

        // We instert the wrapper class before the expression that contained the lambda
        Owner.addTracedReplacement(SM, functor_range, rso_fptrclass.str(), SM.getSpellingLineNumber(E->getLocStart()));
    }

    ++AcceptedChanges;
}

const char ReplaceLambdaID[] = "ReplaceLambda";

struct ReplaceLambdaFactory : TransformFactory {
    ReplaceLambdaFactory() {
        Since.Clang = Version(3, 1);
        Since.Gcc = Version(4, 5);
        Since.Icc = Version(13);
        Since.Msvc = Version(12);
    }

    Transform *createTransform(const TransformOptions &Opts) override {
        TransformHandler *handler = new TransformHandler(ReplaceLambdaID, Opts);
        handler->initReplacers(new LambdaReplacer(handler->getAcceptedChanges(), *handler), makeLambdaExprMatcher);
        return handler;
    }
};

// Register the factory using this statically initialized variable.
static TransformFactoryRegistry::Add<ReplaceLambdaFactory>
X("replace-lambda", "Replaces 'lambda' expressions");
