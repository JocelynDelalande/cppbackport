#include "TransformBase/TransformHandler.h"
#include "Util/TransformUtility.h"
#include "Util/StringUtility.h"
#include "AddConstructorsAssignmMatchers.h"
#include "llvm/Support/Regex.h"
#include <algorithm>
#include <cstddef>

using namespace backport::helper;
using namespace clang::ast_matchers;
using namespace clang::tooling;

typedef ReplacerTemplate<class InsertDefaultMoveAssignmentOp> DefaultMoveAssignmentOpInserter;
typedef ReplacerTemplate<class InsertDefaultCopyAssignmentOp> DefaultCopyAssignmentOpInserter;

typedef ReplacerTemplate<class InsertDefaultConstructors> DefaultConstructorsInserter;
typedef ReplacerTemplate<class InsertCopyConstructors> CopyConstructorsInserter;
typedef ReplacerTemplate<class InsertMoveConstructors> MoveConstructorsInserter;



namespace {
    inline std::string getRvalueCast(std::string type, std::string name, clang::SourceManager &SM, ASTContext &ASTC) {
        return std::string("static_cast< ") + type + " &&>( " + name + " )";
    }

    inline std::string getRvalueCast(QualType const &type, std::string name, clang::SourceManager &SM, ASTContext &ASTC) {
        return std::string("static_cast< ") + printToString(type) + " &&>( " + name + " )";
    }

    std::string genMemberInitializer(clang::QualType const &qt, std::string indexName, std::string elementName, SourceManager &SM, Transform &Owner, ASTContext &ASTC, unsigned short depth, bool tryToMove = false) {
        std::string result = "";
        
        if (qt.getTypePtr()->isArrayType()) {
            result += "\nfor(unsigned long " + indexName + " = 0; " + indexName + " < sizeof(" + elementName + ") / sizeof( " + elementName + "[0] ); ++ " + indexName + " ) {\n";
            result += genMemberInitializer(qt.getTypePtr()->getAsArrayTypeUnsafe()->getElementType(), indexName + "_" + std::to_string(depth + 1), elementName + " [ " + indexName + " ]", SM, Owner, ASTC, depth + 1, tryToMove);
            result += "\n}\n";
        }
        else {
            if (tryToMove && qt.getTypePtr()->isRecordType() == true &&
                qt.getTypePtr()->getAsCXXRecordDecl()->getSourceRange().isValid() && Owner.isFileModifiable(SM, qt.getTypePtr()->getAsCXXRecordDecl()->getRBraceLoc())) {
                
                result += "this->" + elementName + " = " + getRvalueCast(printToString(qt), std::string("other.") + elementName, SM, ASTC) + "; \n";
            }
            else {
                if (qt.getTypePtr()->isRecordType() &&
                    qt.getTypePtr()->getAsCXXRecordDecl()->hasCopyConstructorWithConstParam() == false &&
                    qt.getTypePtr()->getAsCXXRecordDecl()->hasUserDeclaredConstructor() == false)
                    return "";
                result += "this->" + elementName + " = other." + elementName + "; " + (tryToMove? "/*The type of this field doesn't have neither a move constructor nor a move assignment.*/" : "") + " \n";
            }
        }

        return result;
    }

    std::string genDefaultConstr(CXXRecordDecl const *D, Transform &Owner, SourceManager &SM) {
        //for (auto curr : D->ctors()) {
        //    if (curr->isDefaultConstructor() && curr->hasBody()) {
        //        return std::string("/*1000005 Printed using clang print.*/\n") + removeConstexprNoexcept(printToString(*curr));
        //    }
        //}

        for (auto c : D->fields()) {
            if (c->getType()->isLValueReferenceType())
                return "";
        }

        auto policy = getPrintingPolicy();
        
        /*Default constructor:*/
        /*Head*/
        std::string to_be_inserted = "/*1000005 generated by backport own generator.*/\n public: \n" + getNameWithoutTemplateParams(D, Owner, SM) + "() ";

        /*Call Base Constructors in the initializer list.*/
        if (D->bases_begin() != D->bases_end()) {
            to_be_inserted += " : ";
            for (auto baseI = D->bases().begin(); baseI != (D->bases_end() - 1); baseI++) {
                auto base = *baseI;
                to_be_inserted += getNameWithPossiblyTemplateParameters(&base, Owner, SM) + " () , ";
            }
            to_be_inserted += getNameWithPossiblyTemplateParameters(&*(D->bases_end() - 1), Owner, SM) + " () \n";
        }

        /*Body*/
        to_be_inserted += "{ \nthis->operator=(*this);\n }\n";

        return to_be_inserted;
    }

    std::string genMoveConstr(CXXRecordDecl const *D, SourceManager &SM, Transform &Owner, ASTContext &ASTC) {
        //for (auto curr : D->ctors()) {
        //    if (curr->isMoveConstructor() && curr->hasBody()) {
        //        return std::string("/*1000007 Printed using clang print.*/\n") +  removeConstexprNoexcept(printToString(*curr));
        //    }
        //}

        auto policy = getPrintingPolicy();

        /* Move constructor */
        /*Head*/
        std::string to_be_inserted = std::string("/*1000007 generated by backport own generator.*/\n\npublic: \n") + getNameWithoutTemplateParams(D, Owner, SM) + " ( " +
            getNameWithoutTemplateParams(D, Owner, SM) + " &&other ) ";

        /*Call Base Move Constructors in the initializer list*/
        if (D->bases_begin() != D->bases_end()) {
            to_be_inserted += " : ";
            for (auto baseI = D->bases().begin(); baseI != (D->bases_end() - 1); baseI++) {
                auto base = *baseI;
                to_be_inserted += getNameWithPossiblyTemplateParameters(&base, Owner, SM) + " ( " +
                    " " + getRvalueCast(getNameWithPossiblyTemplateParameters(&base, Owner, SM), std::string("static_cast< ") + getNameWithPossiblyTemplateParameters(&base, Owner, SM) + " &>(other)", SM, ASTC) +
                    " ) , ";
            }
            
            to_be_inserted += getNameWithPossiblyTemplateParameters(&*(D->bases_end() - 1), Owner, SM) + " ( " +
                " " + getRvalueCast(getNameWithPossiblyTemplateParameters(&*(D->bases_end() - 1), Owner, SM), std::string("static_cast< ") + getNameWithPossiblyTemplateParameters(&*(D->bases_end() - 1), Owner, SM) + " &>(other)", SM, ASTC) +
                + " ) \n";
        }

        /*Generate initializer list for the reference members.*/
        bool firstInitializer = false;
        if (std::any_of(D->field_begin(), D->field_end(), /*Has a reference typed member.*/
                [](FieldDecl const *i) { return i->getType()->isArrayType() == false; }) &&
            D->bases_begin() == D->bases_end() /*Hasn't put the ':' symbol out yet for the initialzer list.*/
            ) {
        
            to_be_inserted += " : ";
            firstInitializer = true;
        }

        for (auto member : D->fields()) {
            if (member->getType()->isArrayType() == false) {
                if (member->getType()->isRecordType() && 
                    member->getType()->getAsCXXRecordDecl()->hasMoveConstructor() == false && 
                    member->getType()->getAsCXXRecordDecl()->hasCopyConstructorWithConstParam() == false)
                    return "";
                to_be_inserted += (firstInitializer ? " " : " , ") + (std::string)member->getName() + "( " + getRvalueCast(member->getType(), "other." + (std::string)member->getName(), SM, ASTC) + " ) \n";
                firstInitializer = false;
            }
        }

        /*Body*/
        to_be_inserted += "\n{\n";
        for (auto member : D->fields()) {
            if (member->getType()->isArrayType()) {
                std::string mi = genMemberInitializer(member->getType(), "_____backport_initializer_indexer", member->getName(), SM, Owner, ASTC, 0, true);
                if (mi == "")
                    return "";
                to_be_inserted += mi;
            }
        }

        to_be_inserted += "\nthis->operator=(*this);\n";

        to_be_inserted += "\n\n}\n";

        return to_be_inserted;
    }

    std::string genCopyConstr(CXXRecordDecl const *D, SourceManager &SM, Transform &Owner, ASTContext &ASTC) {
        //for (auto curr : D->ctors()) {
        //    if (curr->isCopyConstructor() && curr->hasBody()) {
        //        return std::string("/*1000006  Printed using clang print.*/\n") +  removeConstexprNoexcept(printToString(*curr));
        //    }
        //}

        auto policy = getPrintingPolicy();

        /* Copy constructor */
        /*Head*/
        std::string to_be_inserted = std::string("/*1000006 generated by backport own generator.*/\n\npublic: \n") + getNameWithoutTemplateParams(D, Owner, SM) + " ( " +
            getNameWithoutTemplateParams(D, Owner, SM) + " const &other ) ";

        /*Calling Base constructors in the initializer list.*/
        if (D->bases_begin() != D->bases_end()) {
            to_be_inserted += " : ";
            for (auto baseI = D->bases().begin(); baseI != (D->bases_end() - 1); baseI++) {
                auto base = *baseI;
                to_be_inserted += getNameWithPossiblyTemplateParameters(&base, Owner, SM) + " ( " +
                    " static_cast<" + getNameWithPossiblyTemplateParameters(&base, Owner, SM) + "const &>(other)"
                    + " ) , ";
            }

            to_be_inserted += getNameWithPossiblyTemplateParameters(&*(D->bases_end() - 1), Owner, SM) + " ( " +
                " static_cast<" + getNameWithPossiblyTemplateParameters(&*(D->bases_end() - 1), Owner, SM) + " const &>(other)"
                + " ) \n";
        }

        /*Generate initializer list for the reference members.*/
        bool firstInitializer = false;
        if (std::any_of(D->field_begin(), D->field_end(), /*Has a reference typed member.*/
                [](FieldDecl const *i) { return i->getType()->isArrayType() == false; }) &&
            D->bases_begin() == D->bases_end() /*Hasn't put the ':' symbol out yet for the initialzer list.*/
            ) {

            to_be_inserted += " : ";
            firstInitializer = true;
        }

        for (auto member : D->fields()) {
            if (member->getType()->isArrayType() == false) {
                if (member->getType()->isRecordType() &&
                    member->getType()->getAsCXXRecordDecl()->hasMoveConstructor() == false &&
                    member->getType()->getAsCXXRecordDecl()->hasCopyConstructorWithConstParam() == false)
                    return "";
                to_be_inserted += (firstInitializer ? " " : " , ") + (std::string)member->getName() + "( " + "other." + (std::string)member->getName() + " ) \n";
                firstInitializer = false;
            }
        }

        /*Body*/
        to_be_inserted += "\n{\n";
        for (auto member : D->fields()) {
            if (member->getType()->isArrayType()) {
                std::string mi = genMemberInitializer(member->getType(), "_____backport_initializer_indexer", member->getName(), SM, Owner, ASTC, 0, false);
                if (mi == "")
                    return "";
                to_be_inserted += mi;
            }
        }

        for (auto c : D->fields()) {
            if (c->getType()->isLValueReferenceType())
                return "";
        }

        to_be_inserted += "\nthis->operator=(*this);\n";

        to_be_inserted += "\n\n}\n";

        return to_be_inserted;
    }

    template<class T>
    bool shouldIAddFunctions(Transform &Owner, SourceManager &SM, T const *D) {
        if (D->isUnion())
            return false;

        if (trim(getNameWithoutTemplateParams(D, Owner, SM)) == "VariadicTemplateList")
            return false;

        if (trim(getNameWithoutTemplateParams(D, Owner, SM)) == "VariadicTemplateListEmpty")
            return false;

        return true;
    }
}

template<>
void DefaultConstructorsInserter::run(const MatchFinder::MatchResult &Result) {
    const CXXRecordDecl *D{ Result.Nodes.getDeclAs<CXXRecordDecl>(InsertImplicitDefaultConstructorsId) };
    assert(D && "Bad Callback. No node provided");

    SourceManager &SM = *Result.SourceManager;
    if (D->getRBraceLoc().isInvalid() || !Owner.isFileModifiable(SM, D->getRBraceLoc())) {
        return;
    }

    if (shouldIAddFunctions(Owner, SM, D) == false) {
        return;
    }

    if (D->getTemplateSpecializationKind() ==
        clang::TemplateSpecializationKind::TSK_ImplicitInstantiation) {
        D = D->getTemplateInstantiationPattern();

        if (shouldIAddFunctions(Owner, SM, D) == false) {
            return;
        }

        if (D->getRBraceLoc().isInvalid() || !Owner.isFileModifiable(SM, D->getRBraceLoc())) {
            return;
        }
    }

    std::string name = "";

    if (isUnnamed(D)) {
        name = insertName(D, Owner, SM);
    }

    auto policy = getPrintingPolicy();

    /*Default constructor:*/
    std::string to_be_inserted = genDefaultConstr(D, Owner, SM);
      
    Owner.addTracedReplacement(SM,
        CharSourceRange::getCharRange(D->getRBraceLoc(), D->getRBraceLoc()),
        to_be_inserted);

    ++AcceptedChanges;
}

template<>
void CopyConstructorsInserter::run(const MatchFinder::MatchResult &Result) {
    const CXXRecordDecl *D{ Result.Nodes.getDeclAs<CXXRecordDecl>(InsertImplicitCopyConstructorsId) };
    assert(D && "Bad Callback. No node provided");

    SourceManager &SM = *Result.SourceManager;
    if (D->getRBraceLoc().isInvalid() || !Owner.isFileModifiable(SM, D->getRBraceLoc())) {
        return;
    }

    if (shouldIAddFunctions(Owner, SM, D) == false) {
        return;
    }

    if (D->getTemplateSpecializationKind() ==
        clang::TemplateSpecializationKind::TSK_ImplicitInstantiation) {
        D = D->getTemplateInstantiationPattern();

        if (shouldIAddFunctions(Owner, SM, D) == false) {
            return;
        }

        if (D->getRBraceLoc().isInvalid() || !Owner.isFileModifiable(SM, D->getRBraceLoc())) {
            return;
        }
    }


    std::string name = "";

    if (isUnnamed(D)) {
        name = insertName(D, Owner, SM);
    }

    /*Copy constructor.*/
    std::string to_be_inserted = genCopyConstr(D, SM, Owner, *Result.Context);

    Owner.addTracedReplacement(SM,
        CharSourceRange::getCharRange(D->getRBraceLoc(), D->getRBraceLoc()),
        to_be_inserted);

    ++AcceptedChanges;
}

template<>
void MoveConstructorsInserter::run(const MatchFinder::MatchResult &Result) {
    const CXXRecordDecl *D{ Result.Nodes.getDeclAs<CXXRecordDecl>(InsertImplicitMoveConstructorsId) };
    assert(D && "Bad Callback. No node provided");

    SourceManager &SM = *Result.SourceManager;
    if (D->getRBraceLoc().isInvalid() || !Owner.isFileModifiable(SM, D->getRBraceLoc())) {
        return;
    }

    if (shouldIAddFunctions(Owner, SM, D) == false) {
        return;
    }

    if (D->getTemplateSpecializationKind() ==
        clang::TemplateSpecializationKind::TSK_ImplicitInstantiation) {
        D = D->getTemplateInstantiationPattern();

        if (shouldIAddFunctions(Owner, SM, D) == false) {
            return;
        }

        if (D->getRBraceLoc().isInvalid() || !Owner.isFileModifiable(SM, D->getRBraceLoc())) {
            return;
        }
    }

    std::string name = "";

    if (isUnnamed(D)) {
        name = insertName(D, Owner, SM);
    }

    /*Move constructor.*/
    std::string to_be_inserted = genMoveConstr(D, SM, Owner, *Result.Context);

    Owner.addTracedReplacement(SM,
        CharSourceRange::getCharRange(D->getRBraceLoc(), D->getRBraceLoc()),
        to_be_inserted);

    ++AcceptedChanges;
}

template<>
void DefaultMoveAssignmentOpInserter::run(const MatchFinder::MatchResult &Result) {
    const CXXRecordDecl *D{ Result.Nodes.getDeclAs<CXXRecordDecl>(InsertDefaultMoveAssignmentOpId) };
    assert(D && "Bad Callback. No node provided");

    SourceManager &SM = *Result.SourceManager;
    if (D->getRBraceLoc().isInvalid() || !Owner.isFileModifiable(SM, D->getRBraceLoc())) {
        return;
    }

    if (shouldIAddFunctions(Owner, SM, D) == false) {
        return;
    }

    if (D->getTemplateSpecializationKind() ==
        clang::TemplateSpecializationKind::TSK_ImplicitInstantiation) {
        D = D->getTemplateInstantiationPattern();

        if (shouldIAddFunctions(Owner, SM, D) == false) {
            return;
        }

        if (D->getRBraceLoc().isInvalid() || !Owner.isFileModifiable(SM, D->getRBraceLoc())) {
            return;
        }
    }

    std::string name = "";

    if (isUnnamed(D)) {
            name = insertName(D, Owner, SM);
    }

    std::string to_be_inserted = "";

    //for (auto curr : D->methods()) {
    //    if (curr->isMoveAssignmentOperator() && curr->hasBody()) {
    //        to_be_inserted = std::string("/*1000002 Printed using clang print.*/\n") +  removeConstexprNoexcept(printToString(*curr));
    //    }
    //}

    auto policy = getPrintingPolicy();

    if (to_be_inserted == "") {
        to_be_inserted = std::string("/*1000002 generated by backport own generator.*/\n\npublic: \n") + getNameWithoutTemplateParams(D, Owner, SM) + " &operator= ( " +
            getNameWithoutTemplateParams(D, Owner, SM) + " &&other ) {\n ";

        to_be_inserted += "\n if(&other == this)\n return *this; \n";

        if (D->bases_begin() != D->bases_end())
            to_be_inserted += "*(" + getNameWithPossiblyTemplateParameters(&*(D->bases().begin()), Owner, SM) + " *)(this) = "
            " " + getRvalueCast(getNameWithPossiblyTemplateParameters(&*(D->bases().begin()), Owner, SM), std::string("static_cast< ") + getNameWithPossiblyTemplateParameters(&*(D->bases().begin()), Owner, SM) + " &>(other)", SM, *Result.Context) + ";\n";

        for (auto member : D->fields()) {
            std::string mi = genMemberInitializer(member->getType(), "_____backport_initializer_indexer", member->getName(), SM, Owner, *Result.Context, 0, true);
            if (mi == "")
                return;
            to_be_inserted += mi;
        }

        to_be_inserted += "\n return *this; \n}\n";
    }
    Owner.addTracedReplacement(SM,
        CharSourceRange::getCharRange(D->getRBraceLoc(), D->getRBraceLoc()),
        to_be_inserted);

    ++AcceptedChanges;
}

template<>
void DefaultCopyAssignmentOpInserter::run(const MatchFinder::MatchResult &Result) {
    const CXXRecordDecl *D{ Result.Nodes.getDeclAs<CXXRecordDecl>(InsertDefaultCopyAssignmentOpId) };
    assert(D && "Bad Callback. No node provided");

    SourceManager &SM = *Result.SourceManager;
    if (D->getRBraceLoc().isInvalid() || !Owner.isFileModifiable(SM, D->getRBraceLoc())) {
        return;
    }

    if (shouldIAddFunctions(Owner, SM, D) == false) {
        return;
    }

    if (D->getTemplateSpecializationKind() ==
        clang::TemplateSpecializationKind::TSK_ImplicitInstantiation) {
        D = D->getTemplateInstantiationPattern();

        if (shouldIAddFunctions(Owner, SM, D) == false) {
            return;
        }

        if (D->getRBraceLoc().isInvalid() || !Owner.isFileModifiable(SM, D->getRBraceLoc())) {
            return;
        }
    }

    std::string name = "";

    if (isUnnamed(D)) {
        name = insertName(D, Owner, SM);
    }


    std::string to_be_inserted = "";

    //for (auto curr : D->methods()) {
    //    if (curr->isCopyAssignmentOperator() && curr->hasBody()) {
    //        to_be_inserted = std::string("/*1000003 Printed using clang print.*/\n") +  removeConstexprNoexcept(printToString(*curr));
    //    }
    //}

    if (to_be_inserted == "") {
        auto policy = getPrintingPolicy();

        to_be_inserted = std::string("/*1000003 generated by backport own generator.*/\n\npublic: \n") + getNameWithoutTemplateParams(D, Owner, SM) + " &operator= ( " +
            getNameWithoutTemplateParams(D, Owner, SM) + " const &other )  { \n";

        to_be_inserted += "\n if(&other == this)\n return *this; \n";

        if (D->bases_begin() != D->bases_end())
            to_be_inserted += "*(" + getNameWithPossiblyTemplateParameters(&*(D->bases().begin()), Owner, SM) + " *)(this) = "
            " *( " + getNameWithPossiblyTemplateParameters(&*(D->bases().begin()), Owner, SM) + " *)(&other);\n";

        for (auto member : D->fields()) {
            std::string mi = genMemberInitializer(member->getType(), "_____backport_initializer_indexer", member->getName(), SM, Owner, *Result.Context, 0, false);
            if (mi == "")
                return;
            to_be_inserted += mi;
        }

        to_be_inserted += "\n return *this; \n}\n";
    }
    Owner.addTracedReplacement(SM,
        CharSourceRange::getCharRange(D->getRBraceLoc(), D->getRBraceLoc()),
        to_be_inserted);

    ++AcceptedChanges;
}

const char GenConstructorsID[] = "AddConstructorsAssignm";

struct AddConstructorsAssignmFactory : TransformFactory {
    AddConstructorsAssignmFactory() {
        Since.Clang = Version(2, 9);
        Since.Gcc = Version(4, 4);
        Since.Icc = Version(12);
        Since.Msvc = Version(10);
    }

    Transform *createTransform(const TransformOptions &Opts) override {
        TransformHandler *handler = new TransformHandler(GenConstructorsID, Opts, TransformPriorities::GEN_CONSTR);
        auto &acc = handler->getAcceptedChanges();
#ifdef IMPLICIT_MOVE_CTRS
        handler->initReplacers(
            //new DelegatingConstructorReplacer(acc, *handler), makeDelegatingConstructorMatcher,
            new DefaultMoveAssignmentOpInserter(acc, *handler), makeInsertDefaultMoveAssignmentOpMatcher,
            new DefaultCopyAssignmentOpInserter(acc, *handler), makeInsertDefaultCopyAssignmentOpMatcher,

            new DefaultConstructorsInserter(acc, *handler), makeInsertImplicitDefaultConstructorsMatcher,
            new CopyConstructorsInserter(acc, *handler), makeInsertImplicitCopyConstructorsMatcher,
            new MoveConstructorsInserter(acc, *handler), makeInsertImplicitMoveConstructorsMatcher
        );
#endif
        return handler;
    }
};

// Register the factory using this statically initialized variable.
static TransformFactoryRegistry::Add<AddConstructorsAssignmFactory>
X("gen-constructors-assignment", "Generating constructors and assignments, for class-like structures.");
